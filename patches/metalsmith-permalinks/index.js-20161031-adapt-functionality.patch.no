--- ../metalsmith-permalinks/lib/index.js 2016-10-31 20:54:02.000000000 +0100
+++ ../metalsmith-permalinks/lib/index.js 2016-10-31 20:53:36.000000000 +0100
@@ -44,8 +44,6 @@
     };
   }
 
-  var dupes = {};
-
   function findLinkset(file) {
     var set = find(linksets, function(ls) { 
         return Object.keys(ls.match).reduce(function(sofar, key) {
@@ -69,36 +67,32 @@
       var data = files[file];
       debug('checking file: %s', file);
 
-      if (!html(file)) return;
+      if (!match(file, options.selectors)) return;
       if (data['permalink'] === false) return;
 
       var linkset = merge({}, findLinkset(data), defaultLinkset);
       debug('applying pattern: %s to file: %s', linkset.pattern, file);
 
-      var path = replace(linkset.pattern, data, linkset) || resolve(file);
-      var fam = family(file, files);
+      // Now `:basename` can be used as pattern in a linkset
+      data.basename = path.basename(file, path.extname(file));
+
+      var parsedPath = replace(linkset.pattern, data, linkset) || resolve(file);
+      var sibs = siblings(file, files, options.selectors);
 
-      if (linkset.relative) {
-        // track duplicates for relative files to maintain references
-        for (var key in fam) {
-          var rel = join(path, key);
-          dupes[rel] = fam[key];
-        }
+      // Copy assets along with the index file
+      for (var key in sibs) {
+        var sibpath = replace(linkset.pattern, data, linkset) + '/' + basename(key);
+        delete files[key];
+        files[sibpath] = sibs[key];
       }
 
       // add to path data for use in links in templates
-      data.path = '.' == path ? '' : path;
+      data.path = '.' == parsedPath ? '' : parsedPath;
 
-      var out = join(path, options.indexFile || 'index.html');
+      var out = join(parsedPath, options.indexFile || 'index.html');
       delete files[file];
       files[out] = data;
     });
-
-    // add duplicates for relative files after processing to avoid double-dipping
-    // note: `dupes` will be empty if `options.relative` is false
-    Object.keys(dupes).forEach(function(dupe){
-      files[dupe] = dupes[dupe];
-    })
   };
 }
 
@@ -132,14 +131,14 @@
 }
 
 /**
- * Get a list of sibling and children files for a given `file` in `files`.
+ * Get a list of sibling files for a given `file` in `files`.
  *
  * @param {String} file
  * @param {Object} files
  * @return {Object}
  */
 
-function family(file, files){
+function siblings(file, files, patterns) {
   var dir = dirname(file);
   var ret = {};
 
@@ -148,9 +147,11 @@
   for (var key in files) {
     if (key == file) continue;
     if (key.indexOf(dir) != 0) continue;
-    if (html(key)) continue;
+    if (match(key, patterns)) continue;
     var rel = key.slice(dir.length);
-    ret[rel] = files[key];
+    var keydir = dirname(key);
+    if (dir.indexOf(keydir) != 0) continue;
+    ret[key] = files[key];
   }
 
   return ret;
@@ -213,12 +214,19 @@
 }
 
 /**
- * Check whether a file is an HTML file.
+ * Check whether a file has to be processed.
  *
  * @param {String} path
+ * @param {Array} patterns
  * @return {Boolean}
  */
 
-function html(path){
-  return /.html/.test(extname(path));
+function match(path, patterns) {
+  var match = require('multimatch');
+  for (var i = 0; i < patterns.length; i++) {
+    if (match(path, patterns[i]).length > 0) {
+      return true;
+    }
+  }
+  return false;
 }

